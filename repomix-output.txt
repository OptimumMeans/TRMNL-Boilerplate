This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-29T00:46:34.292Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.env.template
.gitignore
README.md
render.yaml
requirements.txt
src/app.py
src/config.py
src/services/api_service.py
src/services/display.py
src/utils/__init__.py
src/utils/formatters.py
src/utils/validators.py
tests/test_display.py

================================================================
Repository Files
================================================================

================
File: .env.template
================
# Server Configuration
PORT=8080
HOST=0.0.0.0
DEBUG=False

# Plugin Configuration
REFRESH_INTERVAL=900  # 15 minutes in seconds

# TRMNL Configuration
TRMNL_API_KEY=your_trmnl_api_key_here
TRMNL_PLUGIN_UUID=your_plugin_uuid_here

# Display Configuration
DISPLAY_WIDTH=800
DISPLAY_HEIGHT=480

# Cache Configuration
CACHE_TIMEOUT=600  # 10 minutes in seconds

================
File: .gitignore
================
# Project-specific files
.env
api_test.py

# Python
__pycache__/
*.py[cod]
*.class
.Python
env/
venv/
build/
dist/
*.egg-info/

# IDE
.idea/
.vscode/
*.swp

# OS
.DS_Store
Thumbs.db

# Logs
*.log
logs/

# Testing
.coverage
htmlcov/
.pytest_cache/

================
File: README.md
================
# TRMNL Plugin Boilerplate

A boilerplate template for creating TRMNL e-ink display plugins.

## Features

- Flask-based webhook endpoint with CORS support
- E-ink display optimization
- Built-in caching system
- Comprehensive error handling
- Structured logging
- Environment-based configuration management
- Display generator service with error display support
- API service template with caching
- Extensive utility functions for formatting and validation

## Prerequisites

- Python 3.12+
- TRMNL device and API key
- Docker (optional)

## Installation

1. Clone the repository:
```bash
git clone https://github.com/yourusername/your-plugin.git
cd your-plugin
```

2. Create and activate a virtual environment:
```bash
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
```

3. Install dependencies:
```bash
pip install -r requirements.txt
```

4. Create .env file:
```bash
cp .env.template .env
```

5. Update .env with your configuration:
```
TRMNL_API_KEY=your_api_key_here
TRMNL_PLUGIN_UUID=your_plugin_uuid_here
```

## Development

### Running Locally

```bash
python -m src.app
```

The development server will automatically open your default browser to the webhook endpoint. You can access:
- Home page: http://localhost:8080/
- Webhook endpoint: http://localhost:8080/webhook

### Project Structure
```
├── .env.template         # Environment variables template
├── .gitignore           # Git ignore rules
├── README.md            # Project documentation
├── render.yaml          # Render deployment configuration
├── requirements.txt     # Python dependencies
├── src/                 # Source code directory
│   ├── app.py          # Main application entry point
│   ├── config.py       # Configuration management
│   ├── services/       # Core services
│   │   ├── api_service.py    # API interaction service
│   │   └── display.py        # Display generation service
│   └── utils/          # Utility functions
│       ├── __init__.py      # Package exports
│       ├── formatters.py    # Data formatting utilities
│       └── validators.py    # Data validation utilities
└── tests/              # Test files
    └── test_display.py  # Display service tests
```

### Core Components

1. **API Service** (`src/services/api_service.py`)
   - Handles all API interactions
   - Implements caching mechanism
   - Tracks last update timestamp

2. **Display Generator** (`src/services/display.py`)
   - Creates optimized images for e-ink display
   - Handles error displays
   - Supports status bar and content layout

3. **Utility Functions**
   - `formatters.py`: Date/time formatting, API response formatting
   - `validators.py`: Data validation, string sanitization
   - Common utilities exported through `__init__.py`

4. **Configuration** (`src/config.py`)
   - Environment-based configuration
   - Validation for required settings
   - Default values for optional settings

### Creating Your Plugin

1. Modify `src/services/api_service.py` to implement your data fetching logic
2. Update `src/services/display.py` to customize the display layout
3. Add any additional utilities in `src/utils/`
4. Update configuration in `src/config.py` as needed

## Testing

Run the test suite:

```bash
python -m pytest tests/
```

Current test coverage includes:
- Display generator initialization
- Error display generation
- API service functionality
- Display creation with mock data

## Deployment

Deploy using render.yaml configuration:

```bash
render deploy
```

The render.yaml file includes:
- Python 3.12.0 runtime
- Gunicorn web server
- Environment variable configuration
- Build and start commands

## Contributing

1. Fork the repository
2. Create your feature branch
3. Commit your changes
4. Push to the branch
5. Create a Pull Request

## License

MIT

================
File: render.yaml
================
services:
  - type: web
    name: trmnl-plugin
    env: python
    buildCommand: pip install -r requirements.txt
    startCommand: gunicorn src.app:app
    envVars:
      - key: PYTHON_VERSION
        value: 3.12.0
      - key: PORT
        value: 8080
      - key: TRMNL_API_KEY
        sync: false
      - key: TRMNL_PLUGIN_UUID
        sync: false

================
File: requirements.txt
================
flask==3.0.0
pillow==10.1.0
requests==2.31.0
python-dotenv==1.0.0
gunicorn==21.2.0
pytz==2024.1
pymemcache==4.0.0
python-dateutil==2.8.2
flask-cors==4.0.0

================
File: src/app.py
================
from flask import Flask, Response, jsonify
from flask_cors import CORS
import logging
from datetime import datetime, UTC
import traceback
import os
import webbrowser
from threading import Timer

from .config import Config
from .services.display import DisplayGenerator
from .services.api_service import APIService
from .utils.formatters import format_timestamp

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Initialize Flask app
app = Flask(__name__)
CORS(app)

# Initialize services
api_service = APIService()
display_generator = DisplayGenerator(Config.DISPLAY_WIDTH, Config.DISPLAY_HEIGHT)

def open_browser():
    webbrowser.open('http://localhost:8080/webhook')

@app.route('/')
def home():
    return jsonify({
        'name': 'TRMNL Plugin',
        'description': 'TRMNL Plugin Boilerplate',
        'version': '1.0.0',
        'status': 'running',
        'last_update': api_service.last_update.isoformat() if api_service.last_update else None,
        'refresh_interval': Config.REFRESH_INTERVAL
    })

@app.route('/webhook', methods=['GET'])
def trmnl_webhook():
    try:
        data = api_service.get_data()
        logger.info(f'Data retrieved: {data}')
        
        image_data = display_generator.create_display(data)
        
        return Response(
            image_data,
            mimetype='image/bmp',
            headers={
                'X-TRMNL-Refresh': str(Config.REFRESH_INTERVAL),
                'X-TRMNL-Plugin-UUID': Config.TRMNL_PLUGIN_UUID
            }
        )
        
    except Exception as e:
        logger.error(f'Webhook error: {str(e)}')
        logger.error(traceback.format_exc())
        return Response(
            display_generator.create_error_display(str(e)),
            mimetype='image/bmp'
        )

if __name__ == '__main__':
    print('=' * 80)
    print('TRMNL Plugin Development Server')
    print('=' * 80)
    print(f'Server URL: http://localhost:{Config.PORT}')
    print(f'Webhook URL: http://localhost:{Config.PORT}/webhook')
    print('-' * 80)
    print('Opening webhook URL in browser...')
    print('Press Ctrl+C to quit')
    print('=' * 80)
    
    # Open browser after a short delay
    Timer(1.5, open_browser).start()
    
    app.run(
        host=Config.HOST,
        port=Config.PORT,
        debug=Config.DEBUG
    )

================
File: src/config.py
================
import os
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

class Config:
    '''Application configuration.'''
    
    # Server Configuration
    HOST = os.getenv('HOST', '0.0.0.0')
    PORT = int(os.getenv('PORT', 8080))
    DEBUG = os.getenv('DEBUG', 'False').lower() == 'true'
    
    # Plugin Configuration
    REFRESH_INTERVAL = int(os.getenv('REFRESH_INTERVAL', '900'))
    
    # TRMNL Configuration
    TRMNL_API_KEY = os.getenv('TRMNL_API_KEY')
    TRMNL_PLUGIN_UUID = os.getenv('TRMNL_PLUGIN_UUID')
    
    # Display Configuration
    DISPLAY_WIDTH = int(os.getenv('DISPLAY_WIDTH', '800'))
    DISPLAY_HEIGHT = int(os.getenv('DISPLAY_HEIGHT', '480'))
    
    # Cache Configuration
    CACHE_TIMEOUT = int(os.getenv('CACHE_TIMEOUT', '600'))
    
    @classmethod
    def validate(cls):
        '''Validate required configuration.'''
        required_keys = [
            'TRMNL_API_KEY',
            'TRMNL_PLUGIN_UUID'
        ]
        
        missing_keys = [key for key in required_keys if not getattr(cls, key)]
        
        if missing_keys:
            raise ValueError(
                f"Missing required configuration: {', '.join(missing_keys)}"
            )

================
File: src/services/api_service.py
================
from datetime import datetime, UTC
import logging
from typing import Optional, Dict, Any
from ..config import Config

logger = logging.getLogger(__name__)

class APIService:
    '''Service for handling API interactions.'''
    
    def __init__(self):
        self.last_update = None
        self._cached_data = None
        self._cache_timestamp = None
    
    def get_data(self) -> Optional[Dict[str, Any]]:
        '''Get data from your API or source.'''
        try:
            # Check cache first
            if self._is_cache_valid():
                return self._cached_data
            
            # Implement your data fetching logic here
            data = self._fetch_data()
            
            # Update cache
            self._update_cache(data)
            self.last_update = datetime.now(UTC)
            
            return data
            
        except Exception as e:
            logger.error(f"Error fetching data: {str(e)}")
            return None
    
    def _fetch_data(self) -> Dict[str, Any]:
        '''Implement your data fetching logic here.'''
        # This is where you'd implement your actual API calls
        return {
            'timestamp': datetime.now(UTC).isoformat(),
            'status': 'ok',
            # Add your data here
        }
    
    def _update_cache(self, data: Dict[str, Any]) -> None:
        '''Update the cache with new data.'''
        self._cached_data = data
        self._cache_timestamp = datetime.now(UTC)
    
    def _is_cache_valid(self) -> bool:
        '''Check if cached data is still valid.'''
        if not self._cache_timestamp:
            return False
            
        cache_age = (datetime.now(UTC) - self._cache_timestamp).total_seconds()
        return cache_age < Config.CACHE_TIMEOUT

================
File: src/services/display.py
================
from PIL import Image, ImageDraw, ImageFont
import io
import logging
from datetime import datetime
from typing import Dict, Any, Optional

logger = logging.getLogger(__name__)

class DisplayGenerator:
    def __init__(self, width: int, height: int):
        self.width = width
        self.height = height
        try:
            self.font = ImageFont.truetype(font='arial.ttf', size=32)
        except Exception as e:
            logger.warning(f'Failed to load TrueType font: {e}')
            self.font = ImageFont.load_default()
        
        # Smaller font for status bar
        try:
            self.small_font = ImageFont.truetype(font='arial.ttf', size=16)
        except Exception as e:
            self.small_font = ImageFont.load_default()

    def create_display(self, data: Dict[str, Any]) -> Optional[bytes]:
        '''Create a display image for the TRMNL e-ink display.'''
        try:
            image = Image.new('1', (self.width, self.height), 1)
            draw = ImageDraw.Draw(image)
            
            if not data:
                return self.create_error_display('No data available')
            
            # Draw your content here
            self._draw_content(draw, data)
            self._draw_status_bar(draw, data)
            
            buffer = io.BytesIO()
            image.save(buffer, format='BMP')
            return buffer.getvalue()
            
        except Exception as e:
            logger.error(f'Error generating display: {str(e)}')
            return self.create_error_display(str(e))
    
    def create_error_display(self, error_message: str) -> bytes:
        '''Create an error display.'''
        image = Image.new('1', (self.width, self.height), 1)
        draw = ImageDraw.Draw(image)
        
        draw.text(
            (20, 20),
            'Error',
            font=self.font,
            fill=0
        )
        
        draw.text(
            (20, 50),
            error_message,
            font=self.font,
            fill=0
        )
        
        buffer = io.BytesIO()
        image.save(buffer, format='BMP')
        return buffer.getvalue()
    
    def _draw_content(self, draw: ImageDraw, data: Dict[str, Any]) -> None:
        '''Draw the main content of the display.'''
        # Add padding
        padding = 40
        
        # Draw a border with padding
        draw.rectangle(
            [padding, padding, self.width-padding, self.height-padding],
            outline=0,
            width=2
        )
        
        # Draw "Hello TRMNL!" centered
        text = "Hello TRMNL!"
        text_bbox = draw.textbbox((0, 0), text, font=self.font)
        text_width = text_bbox[2] - text_bbox[0]
        text_height = text_bbox[3] - text_bbox[1]
        
        x = (self.width - text_width) // 2
        y = (self.height - text_height) // 2 - 40  # Move up a bit
        
        draw.text(
            (x, y),
            text,
            font=self.font,
            fill=0
        )
        
        # Add some example stats below
        example_text = "Example Plugin Display"
        bbox = draw.textbbox((0, 0), example_text, font=self.small_font)
        ex_width = bbox[2] - bbox[0]
        
        draw.text(
            ((self.width - ex_width) // 2, y + text_height + 20),
            example_text,
            font=self.small_font,
            fill=0
        )
    
    def _draw_status_bar(self, draw: ImageDraw, data: Dict[str, Any]) -> None:
        '''Draw a status bar at the bottom of the display.'''
        # Draw status bar slightly above bottom
        status_height = 30
        bar_y = self.height - status_height - 10
        
        draw.rectangle(
            [0, bar_y, self.width, bar_y + status_height],
            fill=0
        )
        
        # Format timestamp more nicely
        timestamp = data.get('timestamp', 'Unknown')
        if isinstance(timestamp, str):
            try:
                dt = datetime.fromisoformat(timestamp.replace('Z', '+00:00'))
                timestamp = dt.strftime('%Y-%m-%d %H:%M:%S UTC')
            except ValueError:
                pass
        
        status_text = f'Last Update: {timestamp}'
        draw.text(
            (10, bar_y + 5),
            status_text,
            font=self.small_font,
            fill=1
        )

================
File: src/utils/__init__.py
================
from .formatters import (
    format_timestamp,
    format_error_response,
    format_data_response
)

from .validators import (
    validate_timestamp,
    validate_data,
    sanitize_string
)

__all__ = [
    # Formatters
    'format_timestamp',
    'format_error_response',
    'format_data_response',
    
    # Validators
    'validate_timestamp',
    'validate_data',
    'sanitize_string'
]

================
File: src/utils/formatters.py
================
from datetime import datetime, UTC
from typing import Optional, Dict, Any
from flask import jsonify

def format_timestamp(timestamp: str) -> str:
    '''Format timestamp for display.
    
    Args:
        timestamp: ISO format timestamp or UTC timestamp string
        
    Returns:
        Formatted timestamp string in 'YYYY-MM-DD HH:MM UTC' format
    '''
    try:
        # Handle ISO format
        if 'T' in timestamp:
            dt = datetime.fromisoformat(timestamp.replace('Z', '+00:00'))
        # Handle 'YYYY-MM-DD HH:MM:SS UTC' format
        else:
            dt = datetime.strptime(timestamp.replace(' UTC', ''), '%Y-%m-%d %H:%M:%S')
            dt = dt.replace(tzinfo=UTC)
            
        return dt.strftime('%Y-%m-%d %H:%M UTC')
    except (ValueError, AttributeError):
        return timestamp

def format_error_response(error_message: str, status_code: int = 500) -> Dict[str, Any]:
    '''Format error response for API endpoints.
    
    Args:
        error_message: Error message to return
        status_code: HTTP status code (default 500)
        
    Returns:
        Error response dictionary
    '''
    return jsonify({
        'error': error_message,
        'timestamp': datetime.now(UTC).isoformat(),
        'status': 'error'
    }), status_code

def format_data_response(data: Dict[str, Any]) -> Dict[str, Any]:
    '''Format successful data response.
    
    Args:
        data: Data to return
        
    Returns:
        Formatted response dictionary
    '''
    return {
        'data': data,
        'timestamp': datetime.now(UTC).isoformat(),
        'status': 'success'
    }

================
File: src/utils/validators.py
================
from datetime import datetime
from typing import Optional, Dict, Any, Tuple
import re

def validate_timestamp(timestamp: str) -> bool:
    '''Validate timestamp format.
    
    Args:
        timestamp: Timestamp string
        
    Returns:
        True if valid, False otherwise
    '''
    # Try ISO format
    try:
        datetime.fromisoformat(timestamp.replace('Z', '+00:00'))
        return True
    except ValueError:
        pass
    
    # Try 'YYYY-MM-DD HH:MM:SS UTC' format
    try:
        datetime.strptime(timestamp.replace(' UTC', ''), '%Y-%m-%d %H:%M:%S')
        return True
    except ValueError:
        return False

def validate_data(data: Dict[str, Any]) -> Tuple[bool, Optional[str]]:
    '''Validate data dictionary structure.
    
    Args:
        data: Dictionary containing data to validate
        
    Returns:
        Tuple of (is_valid, error_message)
    '''
    # Add your data validation logic here
    # Example:
    required_fields = ['timestamp']
    
    # Check required fields
    for field in required_fields:
        if field not in data:
            return False, f'Missing required field: {field}'
            
    # Validate timestamp if present
    if 'timestamp' in data and not validate_timestamp(data['timestamp']):
        return False, 'Invalid timestamp format'
    
    return True, None

def sanitize_string(input_str: str, max_length: int = 100) -> str:
    '''Sanitize string input for display.
    
    Args:
        input_str: String to sanitize
        max_length: Maximum allowed length
        
    Returns:
        Sanitized string
    '''
    if not isinstance(input_str, str):
        return ''
    
    # Remove any non-printable characters
    clean_str = ''.join(char for char in input_str if char.isprintable())
    
    # Remove any potential HTML/script tags
    clean_str = re.sub(r'<[^>]*>', '', clean_str)
    
    # Truncate to max length
    return clean_str[:max_length]

================
File: tests/test_display.py
================
from datetime import datetime, UTC
import pytest
from src.services.display import DisplayGenerator
from src.services.api_service import APIService

def test_display_generator_initialization():
    '''Test DisplayGenerator initialization'''
    display = DisplayGenerator(800, 480)
    assert display.width == 800
    assert display.height == 480
    assert display.font is not None

def test_error_display():
    '''Test error display generation'''
    display = DisplayGenerator(800, 480)
    error_msg = 'Test error message'
    image_data = display.create_error_display(error_msg)
    assert image_data is not None
    assert len(image_data) > 0

def test_api_service():
    '''Test APIService basic functionality'''
    service = APIService()
    data = service.get_data()
    assert isinstance(data, dict)
    assert 'timestamp' in data
    assert 'status' in data

def test_display_creation():
    '''Test display creation with mock data'''
    display = DisplayGenerator(800, 480)
    test_data = {
        'timestamp': datetime.now(UTC).isoformat(),
        'status': 'ok',
        'test_value': 123
    }
    image_data = display.create_display(test_data)
    assert image_data is not None
    assert len(image_data) > 0
